#include <mega32.h>
#include <delay.h>
#include <alcd.h>
#include <stdio.h>

#define STEP_DEG 6

void main(void) {
    unsigned char step_seq[] = {0x02, 0x04, 0x08, 0x10};
    signed char step_index = 0;
    signed int current_position = 0;
    signed int target_position = 0;
    unsigned char motor_on = 0;
    unsigned char direction = 0; // 0 = right, 1 = left
    char buf[16];

    DDRB = 0x1E;
    lcd_init(16);

    while (1) {
        // ==== BUTTON HANDLING ====
        if (PIND.0 == 0) { // Start
            delay_ms(50);
            while (PIND.0 == 0);
            if (current_position != target_position) {
                motor_on = 1;
            }
        }

        if (PIND.1 == 0) { // Increment
            delay_ms(50);
            while (PIND.1 == 0);
            target_position += STEP_DEG;
        }

        if (PIND.2 == 0) { // Decrement
            delay_ms(50);
            while (PIND.2 == 0);
            target_position -= STEP_DEG;
        }

        if (PIND.3 == 0) { // Toggle direction
            delay_ms(50);
            while (PIND.3 == 0);
            direction = !direction;
        }

        // ==== LCD UPDATE ====
        lcd_gotoxy(0, 0);
        lcd_putsf("s:");
        if (motor_on) lcd_putsf("on ");
        else lcd_putsf("off");
        lcd_putsf(" d:");
        if (direction) lcd_putsf("left ");
        else lcd_putsf("right");

        lcd_gotoxy(0, 1);
        sprintf(buf, "cur:%d tgt:%d", current_position, target_position);
        lcd_puts(buf);
        lcd_putsf("   ");

        // ==== MOTOR CONTROL ====
        if (motor_on) {
            signed int next_position = current_position + (direction ? -STEP_DEG : STEP_DEG);

            // Only move if next_position is still within bounds
            if ((direction == 0 && next_position <= target_position) ||
                (direction == 1 && next_position >= target_position)) {

                PORTB = step_seq[step_index];

                if (direction == 0) {
                    step_index = (step_index + 1) % 4;
                    current_position += STEP_DEG;
                } else {
                    step_index = (step_index - 1 + 4) % 4;
                    current_position -= STEP_DEG;
                }

                delay_ms(200);
            } else {
                motor_on = 0; // Will not overshoot
            }
        } else {
            PORTB &= 0xE1; // Motor off
        }
    }
}
